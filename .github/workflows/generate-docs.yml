name: Generate Documentation

on:
  workflow_run:
    workflows: ["Update Configs"]
    types:
      - completed
  workflow_dispatch:

permissions:
  contents: write

jobs:
  generate-docs:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          ref: ${{ github.ref }}
          fetch-depth: 0

      - name: Setup Python
        uses: actions/setup-python@v6
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: pip install pyyaml

      - name: Generate Category READMEs (Fixed Tables)
        run: |
          python3 << 'SCRIPT'
          import os
          import urllib.parse
          import yaml
          
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)

          REPO_URL = f"https://github.com/${{ github.repository }}/blob/main"
          CATEGORIES = {
              "THEYAMLS/Official_Examples": "Mihomo å®˜æ–¹ç¤ºä¾‹ (Official)",
              "THEYAMLS/General_Config": "é€šç”¨è¿›é˜¶é…ç½® (General Config)",
              "THEYAMLS/Smart_Mode": "Smart æ¨¡å¼ / è·¯ç”±ä¸“ç”¨ (Smart Mode)",
              "THEYAMLS/Mobile_Modules": "Android æ‰‹æœºæ¨¡å— (Mobile Modules)"
          }
          IGNORE_FILES = ["README.md", "LICENSE", "release_body.md"]

          def clean_cell(text):
              """ä¿®å¤è¡¨æ ¼æ ¼å¼ï¼šè½¬ä¹‰ç«–çº¿ï¼Œæ›¿æ¢æ¢è¡Œ"""
              if text is None: return "N/A"
              s = str(text).replace("|", "&#124;").replace("\n", " ").strip()
              return s if s else "N/A"

          def get_size(path):
              try:
                  size = os.path.getsize(path)
                  return f"{size} B" if size < 1024 else f"{size/1024:.1f} KB"
              except:
                  return "Unknown"

          def analyze(path):
              try:
                  with open(path, "r", encoding="utf-8") as f:
                      content = f.read()
                  if "\t" in content:
                      content = content.replace("\t", "  ")
                  data = yaml.safe_load(content)
                  if not isinstance(data, dict):
                      return None
                  
                  info = {}
                  info["mode"] = data.get("mode", "rule")
                  info["ipv6"] = "âœ…" if str(data.get("ipv6", False)).lower() == "true" else "ğŸš«"
                  info["allow_lan"] = "âœ…" if str(data.get("allow-lan", False)).lower() == "true" else "ğŸš«"
                  info["tun"] = "âœ…" if data.get("tun", {}).get("enable") else "ğŸš«"
                  info["mixed_port"] = data.get("mixed-port", "-")
                  info["ext_ctrl"] = data.get("external-controller", "-")
                  
                  groups = data.get("proxy-groups", [])
                  rules = data.get("rules", [])
                  info["group_count"] = len(groups) if isinstance(groups, list) else 0
                  info["rule_count"] = len(rules) if isinstance(rules, list) else 0
                  
                  info["groups"] = []
                  if isinstance(groups, list):
                      for g in groups[:20]:  # é™åˆ¶é˜²æ­¢è¡¨æ ¼è¿‡é•¿
                          if isinstance(g, dict):
                              name = clean_cell(g.get("name", "Unknown"))
                              gtype = g.get("type", "select")
                              icon = {"url-test": "â™»ï¸", "fallback": "ğŸ”§", "load-balance": "âš–ï¸"}.get(gtype, "ğŸ‘†")
                              info["groups"].append(f"| {icon} {name} | `{gtype}` |")
                  return info
              except Exception as e:
                  print(f"âš ï¸ Parse error {path}: {e}")
                  return None

          def generate(folder, title):
              if not os.path.isdir(folder):
                  return
              
              files = []
              for root, dirs, filenames in os.walk(folder):
                  dirs[:] = [d for d in dirs if not d.startswith('.')]
                  for f in filenames:
                      if f.endswith(('.yaml', '.yml')) and f not in IGNORE_FILES:
                          full = os.path.join(root, f)
                          rel = os.path.relpath(full, folder)
                          files.append((rel, full))
              
              if not files:
                  return
              
              data_map = {}
              for rel, full in files:
                  parsed = analyze(full)
                  if parsed:
                      data_map[rel] = {
                          "size": get_size(full),
                          "info": parsed,
                          "full_path": full
                      }
              
              if not data_map:
                  return

              lines = []
              lines.append(f"# ğŸ“‚ {title}")
              lines.append("")
              lines.append(f"[ğŸ”™ è¿”å›ä¸»é¡µ](../README.md)")
              lines.append("")
              lines.append(f"> ğŸ¤– è‡ªåŠ¨æŠ€æœ¯åˆ†æ | {len(data_map)} ä¸ªé…ç½®æ–‡ä»¶")
              lines.append("")

              # å¯¹æ¯”è¡¨æ ¼ï¼ˆä¿®å¤ç‰ˆï¼‰
              if len(data_map) > 1:
                  lines.append("## âš”ï¸ é…ç½®æ¨ªå‘å¯¹æ¯”")
                  lines.append("")
                  headers = ["ç‰¹æ€§"] + [f"`{os.path.basename(k)}`" for k in data_map.keys()]
                  lines.append("| " + " | ".join(headers) + " |")
                  lines.append("| :--- " + "| :--- " * len(data_map) + "|")
                  
                  # æ–‡ä»¶å¤§å°è¡Œ
                  size_row = ["**å¤§å°**"] + [v["size"] for v in data_map.values()]
                  lines.append("| " + " | ".join(size_row) + " |")
                  
                  # é…ç½®è¡Œ
                  configs = [
                      ("mixed_port", "æ··åˆç«¯å£"), ("ext_ctrl", "é¢æ¿åœ°å€"),
                      ("mode", "è¿è¡Œæ¨¡å¼"), ("tun", "TUN æ¨¡å¼"),
                      ("group_count", "ç­–ç•¥ç»„"), ("rule_count", "è§„åˆ™æ•°")
                  ]
                  for key, label in configs:
                      row = [f"**{label}**"]
                      for v in data_map.values():
                          val = v["info"].get(key, "-")
                          row.append(f"**{val}**" if key in ["group_count", "rule_count"] else clean_cell(val))
                      lines.append("| " + " | ".join(row) + " |")
                  lines.append("")

              # è¯¦æƒ…éƒ¨åˆ†
              lines.append("## ğŸ“„ é…ç½®è¯¦æƒ…")
              lines.append("")
              
              # æŒ‰ä½œè€…åˆ†ç»„
              by_author = {}
              for rel, data in data_map.items():
                  author = rel.split(os.sep)[0] if os.sep in rel else "Root"
                  by_author.setdefault(author, []).append((rel, data))
              
              for author, items in sorted(by_author.items()):
                  lines.append(f"### ğŸ‘¤ {author}")
                  lines.append("")
                  for rel, data in items:
                      fname = os.path.basename(rel)
                      info = data["info"]
                      url = f"{REPO_URL}/{folder}/{urllib.parse.quote(rel.replace(os.sep, '/'))}"
                      
                      lines.append(f"#### ğŸ“ {fname}")
                      lines.append(f"- **è·¯å¾„**: `{rel}` | **å¤§å°**: {data['size']} | [æŸ¥çœ‹æºç ]({url})")
                      lines.append(f"- **æ¨¡å¼**: {info['mode']} | **TUN**: {info['tun']} | **IPv6**: {info['ipv6']}")
                      
                      if info["groups"]:
                          lines.append("<details>")
                          lines.append(f"<summary>ğŸ” ç­–ç•¥ç»„ ({info['group_count']}ä¸ª)</summary>")
                          lines.append("")
                          lines.append("| åç§° | ç±»å‹ |")
                          lines.append("| :--- | :--- |")
                          lines.extend(info["groups"])
                          if info["group_count"] > 20:
                              lines.append(f"| ... | è¿˜æœ‰ {info['group_count']-20} ä¸ª |")
                          lines.append("</details>")
                          lines.append("")
                  lines.append("---")
                  lines.append("")

              out_path = os.path.join(folder, "README.md")
              with open(out_path, "w", encoding="utf-8") as f:
                  f.write("\n".join(lines))
              print(f"âœ… Generated: {out_path}")

          for folder, title in CATEGORIES.items():
              generate(folder, title)
          SCRIPT

      - name: Update Root README (Safe Inject)
        run: |
          python3 << 'SCRIPT'
          import os
          import re

          # æ ‡è®°å®šä¹‰ï¼ˆå¿…é¡»ä¸ README.md ä¸­çš„æ ‡è®°ä¸€è‡´ï¼‰
          START_MARKER = "<!-- AUTO_GENERATED_START -->"
          END_MARKER = "<!-- AUTO_GENERATED_END -->"
          
          def parse_scripts():
              scripts = {
                  'General_Config': '.github/scripts/download-general.sh',
                  'Smart_Mode': '.github/scripts/download-smart.sh',
                  'Mobile_Modules': '.github/scripts/download-mobile.sh',
                  'Official_Examples': '.github/scripts/download-official.sh'
              }
              
              all_data = {}
              for cat, path in scripts.items():
                  if not os.path.exists(path):
                      print(f"âš ï¸ Script not found: {path}")
                      continue
                  
                  with open(path, 'r', encoding='utf-8', errors='ignore') as f:
                      content = f.read()
                  
                  # æå– URL|è·¯å¾„ æ ¼å¼
                  pattern = r'(https?://[^|\s"\']+)\|([^"\n]+?\.ya?ml)'
                  matches = re.findall(pattern, content)
                  
                  items = []
                  for url, out_path in matches:
                      out_path = out_path.strip()
                      # æå–ä½œè€…
                      if 'github.com' in url or 'raw.githubusercontent.com' in url:
                          parts = url.split('/')
                          author = parts[3] if len(parts) > 3 else 'unknown'
                      else:
                          author = url.split('/')[2].split('.')[0]
                      
                      items.append({
                          'author': author,
                          'filename': os.path.basename(url),
                          'output': out_path.replace('THEYAMLS/', ''),
                          'category': cat,
                          'url': url
                      })
                  all_data[cat] = items
              return all_data

          data = parse_scripts()
          if not data:
              print("âš ï¸ No data parsed, skipping README update")
              exit(0)

          # æ„å»ºæ³¨å…¥å†…å®¹
          lines = [START_MARKER, ""]
          lines.append("## ğŸ“¦ è‡ªåŠ¨åŒæ­¥é…ç½®åˆ—è¡¨")
          lines.append("")
          lines.append("| åˆ†ç±» | é…ç½®æ•° | æ–‡æ¡£é“¾æ¥ |")
          lines.append("| :--- | :--- | :--- |")
          
          cat_names = {
              'General_Config': 'é€šç”¨è¿›é˜¶é…ç½®',
              'Smart_Mode': 'Smart æ¨¡å¼ / è·¯ç”±ä¸“ç”¨', 
              'Mobile_Modules': 'Android æ¨¡å—',
              'Official_Examples': 'å®˜æ–¹ç¤ºä¾‹'
          }
          
          for cat, items in data.items():
              if items:
                  name = cat_names.get(cat, cat)
                  doc_link = f"[æŸ¥çœ‹](THEYAMLS/{cat}/README.md)"
                  lines.append(f"| **{name}** | {len(items)} ä¸ª | {doc_link} |")
          
          lines.append("")
          lines.append("### ğŸ“‹ æœ€æ–°æ”¶å½•è¯¦æƒ…")
          lines.append("")
          lines.append("| ä½œè€… | æ–‡ä»¶å | åˆ†ç±» |")
          lines.append("| :--- | :--- | :--- |")
          
          # æ‰å¹³åŒ–å¹¶æ’åº
          all_items = []
          for cat, items in data.items():
              for item in items:
                  item['cat_name'] = cat_names.get(cat, cat)
                  all_items.append(item)
          all_items.sort(key=lambda x: x['author'])
          
          for item in all_items:
              file_link = f"[{item['filename']}](THEYAMLS/{item['output']})"
              lines.append(f"| **{item['author']}** | `{file_link}` | {item['cat_name']} |")
          
          lines.append("")
          lines.append(END_MARKER)
          
          new_block = "\n".join(lines)

          # å®‰å…¨å†™å…¥é€»è¾‘
          readme_path = "README.md"
          if os.path.exists(readme_path):
              with open(readme_path, "r", encoding="utf-8") as f:
                  content = f.read()
              
              if START_MARKER in content and END_MARKER in content:
                  # æ›¿æ¢æ¨¡å¼
                  pattern = re.compile(f"{re.escape(START_MARKER)}.*?{re.escape(END_MARKER)}", re.DOTALL)
                  new_content = pattern.sub(new_block, content)
                  mode = "injected (markers found)"
              else:
                  # è¿½åŠ æ¨¡å¼ï¼ˆä¸è¦†ç›–åŸæœ‰å†…å®¹ï¼‰
                  new_content = content + "\n\n" + new_block
                  mode = "appended (no markers)"
          else:
              # æ–°å»ºæ¨¡å¼
              new_content = f"# ğŸ“¦ Config Collection\n\n{new_block}"
              mode = "created new"

          with open(readme_path, "w", encoding="utf-8") as f:
              f.write(new_content)
          
          print(f"âœ… Root README updated ({mode})")
          SCRIPT

      - name: Generate OpenClash Configs
        run: |
          python3 << 'SCRIPT'
          import os
          import yaml
          from urllib.parse import quote

          SOURCE_BASE = "THEYAMLS"
          OUTPUT_BASE = "Overwrite/THEOPENCLASH"
          REPO_RAW = f"https://raw.githubusercontent.com/${{ github.repository }}/main"
          
          yaml.add_multi_constructor("!", lambda loader, suffix, node: None, Loader=yaml.SafeLoader)
          os.makedirs(OUTPUT_BASE, exist_ok=True)

          count = 0
          for root, dirs, files in os.walk(SOURCE_BASE):
              dirs[:] = [d for d in dirs if not d.startswith('.')]
              for file in files:
                  if not file.endswith(('.yaml', '.yml')):
                      continue
                  
                  full_path = os.path.join(root, file)
                  try:
                      with open(full_path, 'r', encoding='utf-8') as f:
                          data = yaml.safe_load(f)
                      
                      providers = data.get('proxy-providers', {}) if isinstance(data, dict) else {}
                      if not providers:
                          continue
                      
                      rel_dir = os.path.relpath(root, SOURCE_BASE)
                      out_dir = os.path.join(OUTPUT_BASE, rel_dir)
                      os.makedirs(out_dir, exist_ok=True)
                      
                      # æ„å»º Raw URLï¼ˆç¡®ä¿ä½¿ç”¨æ­£æ–œæ ï¼‰
                      rel_path = f"{SOURCE_BASE}/{rel_dir}/{file}".replace(os.sep, "/")
                      raw_url = f"{REPO_RAW}/{quote(rel_path)}"
                      
                      conf_name = os.path.splitext(file)[0] + ".conf"
                      out_file = os.path.join(out_dir, conf_name)
                      
                      lines = [
                          "# OpenClash Overwrite Config",
                          f"# Source: {file}",
                          "",
                          "[General]",
                          "DISABLE_UDP_QUIC = 1",
                          f"DOWNLOAD_FILE = url={raw_url}, path=/etc/openclash/config/{file}, cron=0 6 * * *, force=false",
                          f"CONFIG_FILE = /etc/openclash/config/{file}",
                          "SUB_INFO_URL = $EN_KEY1",
                          "",
                          "[Overwrite]"
                      ]
                      
                      for idx, name in enumerate(providers.keys(), 1):
                          lines.append(f'ruby_map_edit "$CONFIG_FILE" "[\'proxy-providers\']" "{name}" "[\'url\']" "$EN_KEY{idx}"')
                      
                      with open(out_file, 'w', encoding='utf-8') as f:
                          f.write("\n".join(lines))
                      count += 1
                      print(f"âœ… {out_file}")
                      
                  except Exception as e:
                      print(f"âš ï¸ Error {file}: {e}")
          
          print(f"\nğŸ¯ Total generated: {count}")
          SCRIPT

      - name: Generate OpenClash READMEs
        run: |
          python3 << 'SCRIPT'
          import os
          
          BASE = "Overwrite/THEOPENCLASH"
          if not os.path.exists(BASE):
              exit(0)

          # ç”Ÿæˆåˆ†ç±» README
          for cat in os.listdir(BASE):
              cat_path = os.path.join(BASE, cat)
              if not os.path.isdir(cat_path):
                  continue
              
              confs = [f for f in os.listdir(cat_path) if f.endswith('.conf')]
              if not confs:
                  continue
              
              lines = [
                  f"# ğŸ“ {cat}",
                  "",
                  "| é…ç½®æ–‡ä»¶ | è¯´æ˜ |",
                  "| :--- | :--- |"
              ]
              for c in sorted(confs):
                  lines.append(f"| `{c}` | OpenClash è¦†å†™é…ç½® |")
              
              lines.extend(["", "[ğŸ”™ è¿”å›æ€»è§ˆ](../README.md)"])
              
              with open(os.path.join(cat_path, "README.md"), "w", encoding="utf-8") as f:
                  f.write("\n".join(lines))

          # ç”Ÿæˆæ€»è§ˆ
          lines = [
              "# ğŸ“¦ OpenClash è¦†å†™é…ç½®æ€»è§ˆ",
              "",
              "## ğŸ“‚ åˆ†ç±»ç›®å½•",
              ""
          ]
          for cat in sorted(os.listdir(BASE)):
              if os.path.isdir(os.path.join(BASE, cat)):
                  lines.append(f"- ğŸ“ **[{cat}](./{cat}/README.md)**")
          
          lines.extend([
              "",
              "## ğŸš€ ä½¿ç”¨æ–¹æ³•",
              "1. è¿›å…¥åˆ†ç±»ç›®å½•ï¼Œç‚¹å‡» `.conf` æ–‡ä»¶è·å– Raw URL",
              "2. åœ¨ OpenClash çš„ é…ç½®è®¢é˜… ä¸­æ·»åŠ è¯¥ URL",
              "3. è®¾ç½®ç¯å¢ƒå˜é‡ `EN_KEY1`, `EN_KEY2` ç­‰ä¸ºä½ çš„è®¢é˜…é“¾æ¥",
              "",
              "[ğŸ  è¿”å›é¡¹ç›®ä¸»é¡µ](../../README.md)"
          ])
          
          with open(os.path.join(BASE, "README.md"), "w", encoding="utf-8") as f:
              f.write("\n".join(lines))
          SCRIPT

      - name: Generate INI README
        run: |
          python3 << 'SCRIPT'
          import os
          import re

          def parse_ini():
              path = ".github/scripts/download-ini.sh"
              if not os.path.exists(path):
                  return {}
              
              with open(path, 'r', encoding='utf-8') as f:
                  content = f.read()
              
              urls = re.findall(r'https?://[^\s"\']+', content)
              cats = {"ACL4SSR": [], "Airport": [], "General": []}
              
              for url in urls:
                  if 'ACL4SSR' in url:
                      cat = "ACL4SSR"
                  elif any(x in url for x in ['jklolixxs', 'customized', 'airports']):
                      cat = "Airport"
                  else:
                      cat = "General"
                  
                  author = url.split('/')[3] if 'github' in url else url.split('/')[2].split('.')[0]
                  cats[cat].append({
                      'author': author,
                      'file': url.split('/')[-1],
                      'url': url
                  })
              return cats

          data = parse_ini()
          base = "Overwrite/THEINI"
          if not os.path.exists(base) or not data:
              exit(0)

          lines = [
              "# ğŸ“‚ INI è¦†å†™é…ç½®é›†åˆ",
              "",
              "| åˆ†ç±» | æ•°é‡ |",
              "| :--- | :--- |"
          ]
          
          names = {"ACL4SSR": "ACL4SSR ç³»åˆ—", "Airport": "æœºåœºå®šåˆ¶", "General": "é€šç”¨é…ç½®"}
          for k, v in data.items():
              if v:
                  lines.append(f"| **{names.get(k, k)}** | {len(v)} ä¸ª |")
          
          lines.append("")
          
          for k, items in data.items():
              if not items:
                  continue
              lines.append(f"## {names.get(k, k)}")
              lines.append("")
              lines.append("| ä½œè€… | æ–‡ä»¶ | é“¾æ¥ |")
              lines.append("| :--- | :--- | :--- |")
              for item in items:
                  lines.append(f"| **{item['author']}** | `{item['file']}` | [Source]({item['url']}) |")
              lines.append("")

          with open(os.path.join(base, "README.md"), "w", encoding="utf-8") as f:
              f.write("\n".join(lines))
          SCRIPT

      - name: Commit and Push
        run: |
          git config --global user.name "github-actions[bot]"
          git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          
          git add .
          if git diff --staged --quiet; then
            echo "âœ… No changes detected."
            exit 0
          fi
          
          git commit -m "ğŸ¤– Auto: Generate docs & configs $(date +'%Y-%m-%d')"
          git pull origin ${{ github.ref_name }} --rebase --autostash || true
          git push origin HEAD:${{ github.ref_name }}
